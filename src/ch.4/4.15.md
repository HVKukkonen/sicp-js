> Given a one-argument functionf and an object a, f is said to "halt" on a if evaluating the expression f(a) returns a value (as opposed to terminating with an error message or running forever). Show that it is impossible to write a functionhalts that correctly determines whether f halts on a for any functionf and object a. Use the following reasoning: If you had such a functionhalts, you could implement the following program:

>function run_forever() { return run_forever(); }
	
>function strange(f) {
>    return halts(f, f)
>           ? run_forever()
>           : "halted";
>}

>Now consider evaluating the expression strange(strange) and show that any possible outcome (either halting or running forever) violates the intended behavior of halts.

So the exercise instructs us to show by contradiction that there can be no program (here `halts`) telling whether a function halts for a given input so that it correctly evaluates this for any function and input.

Following the substitution model of evaluation for `strange(strange)` we arrive at `halts(strange, strange) ? run_forever() : "halted"`. The contradiction rises when we assess the two possibilities for nature of the program `strange` in terms of halting. Given that `strange` actually halts for an input `strange` its evaluation takes the path calling `run_forever()`. Similarly, if it doesn't halt calling the `halts` function determines it and it returns "halted".

Hence, the existence of a program `halts` is impossible as it would necessitate the existence of a program for which it would be unable to determine its halting correctly.